setwd('~/Dropbox/Graph Assisted Jin/code/')
# BiocManager::install("gage")
# BiocManager::install("gageData")
# BiocManager::install("KEGGprofile")
# BiocManager::install("DEGraph")
# BiocManager::install("predictionet")
library(readr)
library(data.table)
library(dplyr)
library(KEGGprofile)
library(readxl)
library(gage)
library(gageData)
library(reshape2) # wide to long
library(corpcor) # campute partial correlation from correlation matrix
library(devtools)
library(Rcpp)
library(RcppArmadillo)
library(inline)
library(glasso)
library(CVglasso)
library(mvtnorm)
library(expm) # for sqrtm
library(Hotelling)
library(MASS)
library(parallel)
library(highD2pop)  # R package from GCT paper (2015)
library(highmean)
library(DEGraph) # for Graph.T2
library(graph)
library(rrcov)
library(KEGGgraph)
sourced_cycles <- T
library(igraph)
library(predictionet)
### Manhattan plot
library(readr)
library(ggrepel)
library(ggplot2)
library(dplyr)
library(RColorBrewer)
library(clipper) # for removing an edge from graphNEL
# gRbase: need to install an old version so as to use clipper
#install.packages('~/Downloads/gRbase_1.8-3.tar.gz', repos = NULL, type ='source')
library(gRbase)
library(stringr) # for str_detect
# BiocManager::install("KEGGlincs")
library(KEGGlincs)
library(maptools)
library(ggExtra)
library(gtable)
library(gridExtra)
library(gbm)
#library("Rgraphviz")
#library("KEGGgraph")
reduced.graph = F
data(kegg.sets.hs)
data(sigmet.idx.hs)
dat = 'lung_cancer_nature2016'
ge.dir0 = '~/Dropbox/Graph\ Assisted\ Jin/nature2016/'
ge.dir = '~/Dropbox/Graph\ Assisted\ Jin/nature2016-completeDAG/'
ge.file = 'lung_cancer_2016nature.xlsx'
pathway.dir = '~/Dropbox/Graph\ Assisted\ Jin/KEGG/'
graphT2.p = 0.8
alpha = 0.05
###### For real data: use the same def of methods for all graphs!!! 
methods = c("GraphSEM.chisq","GraphSEM.z","Graph.T2","T2","BS","CH-Q","SK","CLX","GCT","aSPU")

#confounders=c('Gender','Age','Race')
n.confounder = 0

#kegg.pathways = substr(names(kegg.sets.hs),1,8)
kegg.pathways1 = data.frame(id=substr(names(kegg.sets.hs),1,8), name=substr(names(kegg.sets.hs),10,1000))
kegg.pathways2 = fread(paste0(pathway.dir,'kegg.hs.list.txt'),header=F)
kegg.pathways2 = as.data.frame(kegg.pathways2)
kegg.pathways2[,1] = substr(kegg.pathways2[,1], 6,13)
kegg.pathways2[,2] = sapply(1:nrow(kegg.pathways2),function(x){strsplit(kegg.pathways2[x,2], ' -')[[1]][1]})
colnames(kegg.pathways2) = c('id','name')
kegg.pathways.combine = kegg.pathways2
for (i in 1:nrow(kegg.pathways1))
{
  if (!(kegg.pathways1[i,1] %in% kegg.pathways.combine[,1]))
  {
    kegg.pathways.combine = rbind(kegg.pathways.combine,kegg.pathways1[i,1])
  }
}
kegg.pathways = kegg.pathways.combine[,1]
kegg.names = kegg.pathways.combine[,2]
# 123: Cytokine-cytokine receptor interaction
# 299: Pathways in cancer

graph.T2.test = function (X1, X2, G = NULL, lfA = NULL, ..., k = ncol(X1),nmin) 
{
  tol <- 1e-08
  p <- ncol(X1)
  U <- lfA$U
  egVal <- lfA$l
  kIdx <- (egVal <= max(egVal[k], tol))
  rk <- max(which(kIdx))
  rk = min(rk,nmin)
  ut <- T2.test(X1 %*% U[, 1:rk, drop = FALSE], X2 %*% U[, 
                                                         1:rk, drop = FALSE])
}
# These are just KEGG, GO and BioCarta gene sets for the default species, i.e. human.
# sigmet.idx.hs is a index numbers of sinaling and metabolic pathways in kegg.set.gs. 
# In other words, KEGG pathway include other types of pathway definitions, like "Global Map" and "Human Diseases", 
# which are frequently undesirable in pathway analysis. Therefore, kegg.sets.hs[sigmet.idx.hs] gives you the 
# "cleaner" gene sets of sinaling and metabolic pathways only.
source("rfunctions.R")
species = 'hsa'
### Cardiovascular disease
# Diagnosis of Coronary Heart Diseases Using Gene Expression Profiling; Stable Coronary Artery Disease, Cardiac Ischemia with and without Myocardial Necrosis

# read gene expression data
GE = read_xlsx(paste0(ge.dir0,ge.file),sheet = 'Expression', col_names = T, col_types = c('text',rep('numeric',576))) # 20429 * 577
ge.genes = GE[,1][[1]]
GE = as.data.frame(GE)
colnames(GE)[2:ncol(GE)] = gsub('\\.','-',colnames(GE)[2:ncol(GE)])
# read patient info
patientinfo = read_xlsx(paste0(ge.dir0,ge.file),sheet = 'Patients', col_names = T) 
patientinfo = as.data.frame(patientinfo) # 516
patientinfo = patientinfo[!(is.na(patientinfo$Pat_Stage)),] # 514
rownames(patientinfo) = patientinfo[,'Pat_ID']


# delete the ones that do not have confounders
#patientinfo = patientinfo[complete.cases(patientinfo[,name.confounder]),]
# read sample info
sampleinfo = read_xlsx(paste0(ge.dir0,ge.file),sheet = 'Samples', col_names = T) 
sampleinfo = as.data.frame(sampleinfo)
rownames(sampleinfo) = sampleinfo[,'Sam_Name']
# delete the ones that do not have confounders
sampleinfo = sampleinfo[sampleinfo[,'Sam_Patient'] %in% rownames(patientinfo),]
#### basic info about KEGG pathways
KEGG_testing = function(pathwayID)
{
  pathway.index = which(kegg.pathways == pathwayID)
  getKGMLurl(pathwayID)
  tmp <- paste0(pathway.dir,pathwayID,'.xml')
  if (!file.exists(tmp)) retrieveKGML(pathwayid=substr(pathwayID,4,8), organism='hsa', destfile=tmp, method="curl")
  pathway <- parseKGML(tmp)
  #getName(pathway)
  ### get gene names and indexes in the DAG
  nodes <- nodes(pathway)
  types = sapply(1:length(nodes),function(x){getType(nodes[[x]])})
  genes = sapply(1:length(nodes),function(x){substr(getName(nodes[[x]])[1],5,nchar(getName(nodes[[x]])[1]))})[types == 'gene'] # 279, only keep the first gene in each node
  genes.index = names(nodes)[(types == 'gene')]
  genes.index = genes.index[(genes %in% ge.genes)]
  genes = genes[genes %in% ge.genes]
  names(genes) = genes.index
  ###
  edges <- edges(pathway) # raw: 282 # if error, detach spatstat
  
  if (length(edges) > 0)
  {
    #edgeinfo = sapply(1:length(edges),function(x){getName(edges[[x]])})
    edge.node = t(sapply(1:length(edges),function(x){getEntryID(edges[[x]])}))
    keep.indx = which(((edge.node[,1] %in% genes.index)&(edge.node[,2] %in% genes.index)) == T)
    edge.node = edge.node[keep.indx,] # filter out the nodes that are not genes
    # up to now, all the graphs with n.genes>0 are included
    
    ## get subtype name
    # https://www.kegg.jp/kegg/xml/docs/
    edge.subtype = lapply(1:length(edges),function(x){getSubtype(edges[[x]])})
    edge.subtype.length = sapply(1:length(edge.subtype),function(x){length(edge.subtype[[x]])})
    edge.types = vector('list',length(edge.subtype.length))
    tem.indx = which(edge.subtype.length == 0)
    if (length(tem.indx)>0)
    {
      edge.types[-tem.indx] <- lapply(c(1:length(edges))[-tem.indx],function(x){getSubtype(edges[[x]])[[1]]})
      edge.type = rep(NA,length(edge.types))
      edge.type[-tem.indx] <- sapply(c(1:length(edges))[-tem.indx],function(x){getName(edge.types[[x]])})
    }
    if (length(tem.indx)==0)
    {
      edge.types <- lapply(c(1:length(edges)),function(x){getSubtype(edges[[x]])[[1]]})
      edge.type = rep(NA,length(edge.types))
      edge.type <- sapply(c(1:length(edges)),function(x){getName(edge.types[[x]])})
    }
    edge.type = edge.type[keep.indx]
    
    #------------------------ AOAS
    keep.edge.types = c('activation','inhibition','expression','repression')
    edge.info = cbind(matrix(edge.node,ncol=2),matrix(edge.type,ncol=1))
    if (nrow(edge.info) > 0) edge.info = matrix(edge.info[complete.cases(edge.info),],ncol=3)
    if (nrow(edge.info) > 0) edge.info = matrix(edge.info[edge.info[,3] %in% keep.edge.types,],ncol=3)
    if (length(edge.info) == 3) edge.info = matrix(edge.info,nrow=1)
    if (nrow(edge.info) > 0)
    {
      if (reduced.graph == T){
        #### only keep the genes that exist in the preprocessed graph:
        genes = genes[genes.index %in% unique(c(unlist(edge.info[,1]),unlist(edge.info[,2])))]
        #genes.index = genes.index[genes.index %in% unique(c(unlist(edge.info[,1]),unlist(edge.info[,2])))]
        # no need, already in names(genes)
      }
      #### starting from here, we do not gene.index anymore
      #### combine duplicated genes:
      edge.info[,1] = genes[edge.info[,1]]
      edge.info[,2] = genes[edge.info[,2]]
      tem.idx = which(duplicated(edge.info))
      if (length(tem.idx)>0)
      {
        edge.info = edge.info[-tem.idx,]
      }
      genes = unique(genes)
      ## with self loops:
      A0 = matrix(0, length(genes), length(genes))
      ##### Z = QZ + E, Qij: j->i
      for (i in 1:nrow(edge.info))
      {
        A0[which(genes == edge.info[i,2]), which(genes == edge.info[i,1])] = ifelse(edge.info[i,3] %in% c('activation','expression'),1,-1)
      }
      
      #### remove loops:
      loops.index = which(edge.info[,1] == edge.info[,2])
      #if (length(loops.index) > 1) edge.info = edge.info[-loops.index,]
      
      n.activation = sum(edge.info[,3] == 'activation')
      n.inhibition = sum(edge.info[,3] == 'inhibition')
      n.expression = sum(edge.info[,3] == 'expression')
      n.repression = sum(edge.info[,3] == 'repression')
      
      ##### Construct the adjacency matrix A for AOAS
      A = matrix(0, length(genes), length(genes))
      ##### Z = QZ + E, Qij: j->i
      for (i in 1:nrow(edge.info))
      {
        A[which(genes == edge.info[i,2]), which(genes == edge.info[i,1])] = 1 #ifelse(edge.info[i,3] %in% c('activation','expression'),1,-1)
      }
      ### remove self loops
      diag(A) = 0
      abssum = function(x)
      {
        sum(abs(x))
      }
      nonzero.A = apply(A,1,abssum)
      d = max(nonzero.A)
      p = length(genes)
      p0 = sum(nonzero.A > 0)
      sparsity = sum(abs(A) > 0)/p^2
      
      ### DAG?
      #cycles.R_x <- data.frame( V1 = edge.info[,1], V2 = edge.info[,2] )
      #cycles.R_g_x <- graph(t(as.matrix(cycles.R_x)))
      #is_dag(cycles.R_g_x)
      
      ### 
      a=adj.remove.cycles(A,maxlength=p)
      A = a$adjmat.acyclic
      n.circles = sum(a$adjmat.removed)
      
      ##### Hypothesis testing
      n = list(X=nrow(X),Y=nrow(Y))
      nx = n[['X']]; ny = n[['Y']]
      N = n[['X']]+n[['Y']] ### in BS paper 'n' = N-2
      nmin = min(nx,ny) # minimum sample size
      n.confounder = 0
      graph.type = 'DAG'
      #if (N <= p) methods = c("GraphSEM.chisq","GraphSEM.z","Graph.T2","BS","CH-Q","SK","CLX","GCT","aSPU")
      #if (N > p) methods = c("GraphSEM.chisq","GraphSEM.z","Graph.T2","T2","BS","CH-Q","SK","CLX","GCT","aSPU")
      
      
      pval=rep(NA,length(methods)) # calculated p values
      rej=rep(NA,length(methods)) # 1: H0 rejected, 0: H0 not rejected
      names(pval) = names(rej) = methods
      
      ###################### Graph-based T2 Method in Jacob et al. (2012): ######################
      Asym = A0[1:p,1:p]
      basic.info = c(as.character(round(c(unlist(n),p,nrow(edge.info),length(loops.index),d,p0),0)),signif(sparsity,3),n.activation,n.inhibition,n.expression,n.repression,n.circles,
                     sum(!(edge.info[,3] == 'activation')), sum(!(edge.info[,3] == 'expression')), 
                     sum(!(edge.info[,3] == 'inhibition')), sum(!(edge.info[,3] == 'repression')), 
                     sum(!(edge.info[,3] %in% keep.edge.types)))
      names(basic.info) = c('n_x', 'n_y','p','n.edge','n.loop','d','p0','sparisty','n.activation','n.inhibition','n.expression','n.repression','n.circles')
      #report.list = list(basic.info=basic.info,pval=pval) # number of loops, edges, nodes, etc.
      print(paste0('Pathway ', pathway.index, ': ', pathwayID,' Completed'))
      return(basic.info)
    }
  }
}
G=1
grp1 = grps[G,1]
grp2 = grps[G,2]
kegg.results = list()
kegg.empty.indx = c(338,339,340)#,100,112,123,299) #empty files (00300); 112: singular for Graph.t2 for noreduced graphs
for (i in c(1:length(kegg.pathways))[-kegg.empty.indx]){
  kegg.results[[i]] = KEGG_testing(kegg.pathways[i])
}
##### extract the non null results
basic.info = pval = NULL
l = 1
for (i in 1:length(kegg.results)){
  if (length(kegg.results[[i]]) > 0){
    basic.info = rbind(basic.info,as.numeric(kegg.results[[i]]$basic.info))
    basic.info.colnames = names(kegg.results[[i]]$basic.info)
    pval = rbind(pval, kegg.results[[i]]$pval)
    rownames(basic.info)[l] = rownames(pval)[l] = kegg.names[i]
    l = l + 1
  }
}
## i=123 give warning
colnames(basic.info) = basic.info.colnames
pval = signif(pval,2)
#pval = format(pval, scientific=TRUE)
results = cbind(basic.info,pval)
dup.graph = which(duplicated(rownames(results)))
remove.idx = numeric()
for (dup in dup.graph)
{
  temgraph = results[rownames(results) == rownames(results)[dup],]
  temgraph.idx = which(rownames(results) == rownames(results)[dup])
  remove.idx = c(remove.idx,temgraph.idx[-which.max(temgraph[,'n.edge'])])
}
if (length(remove.idx)>0) results = results[-remove.idx,]
#View(results)
basicinfo = results; rm(results)
write.table(basicinfo,file=paste0('~/Dropbox/high-dim two sample testing/manuscript/results_',dat,'_comparison_',grp1,'_',grp2,'.txt'),col.names = T,row.names = T)
###### obtain more info on the identified pathways:
#query <- keggGet("hsa00010")
print(G)








###
for (G in 1:6){
  ########## read results
  gs = list()
  #for (G in 1:nrow(grps)){
  #for (G in 1:nrow(grps_ns)){
  if (comparison == 'tumor-tumor')
  {
    grp1 = grps[G,1]
    grp2 = grps[G,2]
  }
  if (comparison == 'normal-stage')
  {
    grp1 = 'normal'
    grp2 = grp_ns[G,1]
  }
  results = read.table(paste0(ge.dir,'results_',dat,'_comparison_',grp1,'_',grp2,'.txt'), header = T)
  # remove BS:
  results = results[,-which(colnames(results) %in% c('BS','GraphSEM.chisq'))]
  methods.reduced =  c(paste0('T2-DAG'), "Graph T2", "T2", "CH-Q", "SK", "CLX", "GCT", "aSPU")
  
  #results2=read.table(paste0('~/Dropbox/Graph Assisted Jin/nature2016/results_',dat,'_comparison_',grp1,'_',grp2,'.txt'), header = T)
  #results3=results[rownames(results)%in%rownames(results2),]
  ## visualization
  pval = as.matrix(results[,(ncol(results)-length(methods.reduced)+1):(ncol(results))])
  pval = -log10(pval)
  #pval2 = pval[rowSums(pval,na.rm=T)<Inf,]
  pool.indx=which(rowSums(pval,na.rm=T)<Inf)
  pval[which(pval == Inf)] = max(pval[pval<Inf],na.rm=T) + 1
  DAG.index = which(results[,'n.circles']==0)
}



write.table(basicinfo,file=paste0('~/Dropbox/high-dim two sample testing/manuscript/results_',dat,'_comparison_',grp1,'_',grp2,'.txt'),col.names = T,row.names = T)

